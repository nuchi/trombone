function t(t,e){const n=document.createElement("iframe");n.style.cssText="position:absolute;left:0;top:-999px;width:1px;height:1px;",e.appendChild(n);const s=n.contentWindow,a=s.document;let o="var window,$hook";for(const r in s)r in t||"eval"===r||(o+=",",o+=r);for(const r in t)o+=",",o+=r,o+="=self.",o+=r;const i=a.createElement("script");i.appendChild(a.createTextNode(`function $hook(self,console) {"use strict";\n        ${o};return function() {return eval(arguments[0])}}`)),a.body.appendChild(i),this.exec=s.$hook.call(t,t,console)}const e=[];let n;function s(t){const n={};let s=-1;this.parameters.forEach(((t,a)=>{const o=e[++s]||(e[s]=new Float32Array(1));o.fill(t.value),n[a]=o})),this.processor.realm.exec("self.sampleRate=sampleRate="+this.context.sampleRate+";self.currentTime=currentTime="+this.context.currentTime);const o=a(t.inputBuffer),i=a(t.outputBuffer);this.instance.process([o],[i],n)}function a(t){const e=[];for(let n=0;n<t.numberOfChannels;n++)e[n]=t.getChannelData(n);return e}function o(t){return t.$$processors||(t.$$processors={})}"function"==typeof AudioWorkletNode&&"audioWorklet"in AudioContext.prototype||(self.AudioWorkletNode=class extends GainNode{constructor(t,e,a){super(t);const i=o(t)[e],r=a&&a.outputChannelCount?a.outputChannelCount[0]:2;if(this.scriptProcessor=t.createScriptProcessor(256,1,r),a.processorOptions.NUM_FRAMES=256,this.bufferSize=this.scriptProcessor.bufferSize,this.parameters=new Map,i.properties)for(let n=0;n<i.properties.length;n++){const e=i.properties[n],s=t.createGain().gain;s.value=e.defaultValue,this.parameters.set(e.name,s)}const h=new MessageChannel;n=h.port2;const u=new i.Processor(a||{});n=null,this.port=h.port1,this.processor=i,this.instance=u,this.scriptProcessor.onaudioprocess=s.bind(this),GainNode.prototype.connect.call(this,this.scriptProcessor)}connect(t){this.scriptProcessor.connect(t)}},Object.defineProperty((self.AudioContext||self.webkitAudioContext).prototype,"audioWorklet",{get(){return this.$$audioWorklet||(this.$$audioWorklet=new self.AudioWorklet(this))}}),self.AudioWorklet=class{constructor(t){this.$$context=t}addModule(e,s){return fetch(e).then((t=>{if(!t.ok)throw Error(t.status);return t.text()})).then((e=>{const a={sampleRate:this.$$context.sampleRate,currentTime:this.$$context.currentTime,AudioWorkletProcessor:function(){this.port=n},registerProcessor:(t,e)=>{o(this.$$context)[t]={realm:i,context:a,Processor:e,properties:e.parameterDescriptors||[]}}};a.self=a;const i=new t(a,document.documentElement);return i.exec((s&&s.transpile||String)(e)),null}))}});"undefined"==typeof AudioWorkletNode&&alert("AudioWorklet is not supported in this browser !");class i extends AudioWorkletNode{constructor(t,e,n){super(t,"trombone",n),this.baseURL=e,this.json=n.processorOptions.json,this.json_object=JSON.parse(this.json),this.parse_ui=function(t,e){for(var n=0;n<t.length;n++)this.parse_group(t[n],e)},this.parse_group=function(t,e){t.items&&this.parse_items(t.items,e)},this.parse_items=function(t,e){for(var n=0;n<t.length;n++)this.parse_item(t[n],e)},this.parse_item=function(t,e){if("vgroup"===t.type||"hgroup"===t.type||"tgroup"===t.type)this.parse_items(t.items,e);else if("hbargraph"===t.type||"vbargraph"===t.type)e.outputs_items.push(t.address);else if("vslider"===t.type||"hslider"===t.type||"button"===t.type||"checkbox"===t.type||"nentry"===t.type){if(e.inputs_items.push(t.address),e.descriptor.push(t),void 0!==t.meta)for(var n=0;n<t.meta.length;n++)void 0!==t.meta[n].midi&&("pitchwheel"===t.meta[n].midi.trim()?e.fPitchwheelLabel.push({path:t.address,min:parseFloat(t.min),max:parseFloat(t.max)}):"ctrl"===t.meta[n].midi.trim().split(" ")[0]&&e.fCtrlLabel[parseInt(t.meta[n].midi.trim().split(" ")[1])].push({path:t.address,min:parseFloat(t.min),max:parseFloat(t.max)}));var s="set"+t.address,a="get"+t.address;s=s.replace(/\/./g,(t=>t.substr(1,1).toUpperCase())),a=a.replace(/\/./g,(t=>t.substr(1,1).toUpperCase())),e[s]=n=>{e.setParamValue(t.address,n)},e[a]=()=>e.getParamValue(t.address)}},this.output_handler=null,this.inputs_items=[],this.outputs_items=[],this.descriptor=[],this.fPitchwheelLabel=[],this.fCtrlLabel=new Array(128);for(var s=0;s<this.fCtrlLabel.length;s++)this.fCtrlLabel[s]=[];this.parse_ui(this.json_object.ui,this),this.port.onmessage=this.handleMessage.bind(this);try{this.parameters&&this.parameters.forEach((t=>t.automationRate="k-rate"))}catch(a){}}handleMessage(t){var e=t.data;this.output_handler&&this.output_handler(e.path,e.value)}destroy(){this.port.postMessage({type:"destroy"}),this.port.close()}getJSON(){return this.json}async getMetadata(){return new Promise((t=>{let e=""===this.baseURL?"main.json":this.baseURL+"/main.json";fetch(e).then((t=>t.json())).then((e=>{t(e)}))}))}setParamValue(t,e){this.parameters.get(t).setValueAtTime(e,0)}setParam(t,e){this.parameters.get(t).setValueAtTime(e,0)}getParamValue(t){return this.parameters.get(t).value}getParam(t){return this.parameters.get(t).value}setOutputParamHandler(t){this.output_handler=t}getOutputParamHandler(){return this.output_handler}getNumInputs(){return parseInt(this.json_object.inputs)}getNumOutputs(){return parseInt(this.json_object.outputs)}inputChannelCount(){return parseInt(this.json_object.inputs)}outputChannelCount(){return parseInt(this.json_object.outputs)}getParams(){return this.inputs_items}getDescriptor(){var t={};for(const e in this.descriptor)this.descriptor.hasOwnProperty(e)&&"bypass"!=this.descriptor[e].label&&(t=Object.assign({[this.descriptor[e].label]:{minValue:this.descriptor[e].min,maxValue:this.descriptor[e].max,defaultValue:this.descriptor[e].init}},t));return t}ctrlChange(t,e,n){if(this.fCtrlLabel[e]!==[])for(var s=0;s<this.fCtrlLabel[e].length;s++){var a=this.fCtrlLabel[e][s].path;this.setParamValue(a,i.remap(n,0,127,this.fCtrlLabel[e][s].min,this.fCtrlLabel[e][s].max)),this.output_handler&&this.output_handler(a,this.getParamValue(a))}}pitchWheel(t,e){for(var n=0;n<this.fPitchwheelLabel.length;n++){var s=this.fPitchwheelLabel[n];this.setParamValue(s.path,i.remap(e,0,16383,s.min,s.max)),this.output_handler&&this.output_handler(s.path,this.getParamValue(s.path))}}midiMessage(t){var e=t[0]>>4,n=15&t[0],s=t[1],a=t[2];9!==n&&(11===e?this.ctrlChange(n,s,a):14===e&&this.pitchWheel(n,128*a+s))}onMidi(t){midiMessage(t)}async getState(){var t=new Object;for(let e=0;e<this.getParams().length;e++)Object.assign(t,{[this.getParams()[e]]:`${this.getParam(this.getParams()[e])}`});return new Promise((e=>{e(t)}))}async setState(t){return new Promise((e=>{for(const s in t)t.hasOwnProperty(s)&&this.setParam(s,t[s]);try{this.gui.setAttribute("state",JSON.stringify(t))}catch(n){console.warn("Plugin without gui or GUI not defined",n)}e(t)}))}setPatch(t){this.setState(this.presets[t])}static remap(t,e,n,s,a){return 1*(t-e)/(n-e)*(a-s)+s}}const r=[];class h{constructor(t,e=""){this.context=t,this.baseURL=e,this.pathTable=[],this.fWorkletProcessors=r||[]}heap2Str(t){let e="",n=0;for(;0!==t[n];)e+=String.fromCharCode(t[n++]);return e}async load(){try{const e={env:{memoryBase:0,tableBase:0,_abs:Math.abs,_acosf:Math.acos,_asinf:Math.asin,_atanf:Math.atan,_atan2f:Math.atan2,_ceilf:Math.ceil,_cosf:Math.cos,_expf:Math.exp,_floorf:Math.floor,_fmodf:(t,e)=>t%e,_logf:Math.log,_log10f:Math.log10,_max_f:Math.max,_min_f:Math.min,_remainderf:(t,e)=>t-Math.round(t/e)*e,_powf:Math.pow,_roundf:Math.fround,_sinf:Math.sin,_sqrtf:Math.sqrt,_tanf:Math.tan,_acoshf:Math.acosh,_asinhf:Math.asinh,_atanhf:Math.atanh,_coshf:Math.cosh,_sinhf:Math.sinh,_tanhf:Math.tanh,_acos:Math.acos,_asin:Math.asin,_atan:Math.atan,_atan2:Math.atan2,_ceil:Math.ceil,_cos:Math.cos,_exp:Math.exp,_floor:Math.floor,_fmod:(t,e)=>t%e,_log:Math.log,_log10:Math.log10,_max_:Math.max,_min_:Math.min,_remainder:(t,e)=>t-Math.round(t/e)*e,_pow:Math.pow,_round:Math.fround,_sin:Math.sin,_sqrt:Math.sqrt,_tan:Math.tan,_acosh:Math.acosh,_asinh:Math.asinh,_atanh:Math.atanh,_cosh:Math.cosh,_sinh:Math.sinh,_tanh:Math.tanh,table:new WebAssembly.Table({initial:0,element:"anyfunc"})}};let n=""===this.baseURL?"trombone.wasm":this.baseURL+"/trombone.wasm";const s=await fetch(n),a=await s.arrayBuffer(),o=await WebAssembly.compile(a),r=await WebAssembly.instantiate(o,e);let h=new Uint8Array(r.exports.memory.buffer),p=this.heap2Str(h),c=JSON.parse(p),l={wasm_module:o,json:p,NUM_FRAMES:128};if(-1===this.fWorkletProcessors.indexOf(name))try{let t=/JSON_STR/g,e=u.replace(t,p),n=window.URL.createObjectURL(new Blob([e],{type:"text/javascript"}));await this.context.audioWorklet.addModule(n),this.fWorkletProcessors.push(name)}catch(t){return console.error(t),console.error("Faust "+this.name+" cannot be loaded or compiled"),null}return this.node=new i(this.context,this.baseURL,{numberOfInputs:parseInt(c.inputs)>0?1:0,numberOfOutputs:parseInt(c.outputs)>0?1:0,channelCount:Math.max(1,parseInt(c.inputs)),outputChannelCount:[parseInt(c.outputs)],channelCountMode:"explicit",channelInterpretation:"speakers",processorOptions:l}),this.node.onprocessorerror=()=>{console.log("An error from trombone-processor was detected.")},this.node}catch(t){return console.error(t),console.error("Faust "+this.name+" cannot be loaded or compiled"),null}}async loadGui(){return new Promise(((t,e)=>{try{let e=""===this.baseURL?"main.html":this.baseURL+"/main.html";if(this.linkExists(e)){var n=createtromboneGUI(this.node);t(n)}else{var s=document.createElement("link");s.rel="import",s.href=e,document.head.appendChild(s),s.onload=e=>{var n=createtromboneGUI(this.node);t(n)}}}catch(a){console.log(a),e(a)}}))}linkExists(t){return document.querySelectorAll(`link[href="${t}"]`).length>0}}let u='\n\n    \'use strict\';\n\n    // Monophonic Faust DSP\n    class tromboneProcessor extends AudioWorkletProcessor {\n        \n        // JSON parsing functions\n        static parse_ui(ui, obj, callback)\n        {\n            for (var i = 0; i < ui.length; i++) {\n                tromboneProcessor.parse_group(ui[i], obj, callback);\n            }\n        }\n        \n        static parse_group(group, obj, callback)\n        {\n            if (group.items) {\n                tromboneProcessor.parse_items(group.items, obj, callback);\n            }\n        }\n        \n        static parse_items(items, obj, callback)\n        {\n            for (var i = 0; i < items.length; i++) {\n                callback(items[i], obj, callback);\n            }\n        }\n        \n        static parse_item1(item, obj, callback)\n        {\n            if (item.type === "vgroup"\n                || item.type === "hgroup"\n                || item.type === "tgroup") {\n                tromboneProcessor.parse_items(item.items, obj, callback);\n            } else if (item.type === "hbargraph"\n                       || item.type === "vbargraph") {\n                // Nothing\n            } else if (item.type === "vslider"\n                       || item.type === "hslider"\n                       || item.type === "button"\n                       || item.type === "checkbox"\n                       || item.type === "nentry") {\n                obj.push({ name: item.address,\n                         defaultValue: item.init,\n                         minValue: item.min,\n                         maxValue: item.max });\n            }\n        }\n        \n        static parse_item2(item, obj, callback)\n        {\n            if (item.type === "vgroup"\n                || item.type === "hgroup"\n                || item.type === "tgroup") {\n                tromboneProcessor.parse_items(item.items, obj, callback);\n            } else if (item.type === "hbargraph"\n                       || item.type === "vbargraph") {\n                // Keep bargraph adresses\n                obj.outputs_items.push(item.address);\n                obj.pathTable[item.address] = parseInt(item.index);\n            } else if (item.type === "vslider"\n                       || item.type === "hslider"\n                       || item.type === "button"\n                       || item.type === "checkbox"\n                       || item.type === "nentry") {\n                // Keep inputs adresses\n                obj.inputs_items.push(item.address);\n                obj.pathTable[item.address] = parseInt(item.index);\n            }\n        }\n     \n        static get parameterDescriptors() \n        {\n            // Analyse JSON to generate AudioParam parameters\n            var params = [];\n            tromboneProcessor.parse_ui(JSON.parse(`JSON_STR`).ui, params, tromboneProcessor.parse_item1);\n            return params;\n        }\n       \n        constructor(options)\n        {\n            super(options);\n            this.running = true;\n            this.NUM_FRAMES = options.processorOptions.NUM_FRAMES;\n            const NUM_FRAMES = options.processorOptions.NUM_FRAMES;\n            // console.log(NUM_FRAMES);\n\n            const importObject = {\n                    env: {\n                        memoryBase: 0,\n                        tableBase: 0,\n\n                        // Integer version\n                        _abs: Math.abs,\n\n                        // Float version\n                        _acosf: Math.acos,\n                        _asinf: Math.asin,\n                        _atanf: Math.atan,\n                        _atan2f: Math.atan2,\n                        _ceilf: Math.ceil,\n                        _cosf: Math.cos,\n                        _expf: Math.exp,\n                        _floorf: Math.floor,\n                        _fmodf: function(x, y) { return x % y; },\n                        _logf: Math.log,\n                        _log10f: Math.log10,\n                        _max_f: Math.max,\n                        _min_f: Math.min,\n                        _remainderf: function(x, y) { return x - Math.round(x/y) * y; },\n                        _powf: Math.pow,\n                        _roundf: Math.fround,\n                        _sinf: Math.sin,\n                        _sqrtf: Math.sqrt,\n                        _tanf: Math.tan,\n                        _acoshf: Math.acosh,\n                        _asinhf: Math.asinh,\n                        _atanhf: Math.atanh,\n                        _coshf: Math.cosh,\n                        _sinhf: Math.sinh,\n                        _tanhf: Math.tanh,\n\n                        // Double version\n                        _acos: Math.acos,\n                        _asin: Math.asin,\n                        _atan: Math.atan,\n                        _atan2: Math.atan2,\n                        _ceil: Math.ceil,\n                        _cos: Math.cos,\n                        _exp: Math.exp,\n                        _floor: Math.floor,\n                        _fmod: function(x, y) { return x % y; },\n                        _log: Math.log,\n                        _log10: Math.log10,\n                        _max_: Math.max,\n                        _min_: Math.min,\n                        _remainder:function(x, y) { return x - Math.round(x/y) * y; },\n                        _pow: Math.pow,\n                        _round: Math.fround,\n                        _sin: Math.sin,\n                        _sqrt: Math.sqrt,\n                        _tan: Math.tan,\n                        _acosh: Math.acosh,\n                        _asinh: Math.asinh,\n                        _atanh: Math.atanh,\n                        _cosh: Math.cosh,\n                        _sinh: Math.sinh,\n                        _tanh: Math.tanh,\n\n                        table: new WebAssembly.Table({ initial: 0, element: \'anyfunc\' })\n                    }\n            };\n            \n            this.trombone_instance = new WebAssembly.Instance(options.processorOptions.wasm_module, importObject);\n            this.json_object = JSON.parse(options.processorOptions.json);\n         \n            this.output_handler = function(path, value) { this.port.postMessage({ path: path, value: value }); };\n            \n            this.ins = null;\n            this.outs = null;\n\n            this.dspInChannnels = [];\n            this.dspOutChannnels = [];\n\n            this.numIn = parseInt(this.json_object.inputs);\n            this.numOut = parseInt(this.json_object.outputs);\n\n            // Memory allocator\n            this.ptr_size = 4;\n            this.sample_size = 4;\n            this.integer_size = 4;\n            \n            this.factory = this.trombone_instance.exports;\n            this.HEAP = this.trombone_instance.exports.memory.buffer;\n            this.HEAP32 = new Int32Array(this.HEAP);\n            this.HEAPF32 = new Float32Array(this.HEAP);\n\n            // Warning: keeps a ref on HEAP in Chrome and prevent proper GC\n            //console.log(this.HEAP);\n            //console.log(this.HEAP32);\n            //console.log(this.HEAPF32);\n\n            // bargraph\n            this.outputs_timer = 5;\n            this.outputs_items = [];\n\n            // input items\n            this.inputs_items = [];\n        \n            // Start of HEAP index\n\n            // DSP is placed first with index 0. Audio buffer start at the end of DSP.\n            this.audio_heap_ptr = parseInt(this.json_object.size);\n\n            // Setup pointers offset\n            this.audio_heap_ptr_inputs = this.audio_heap_ptr;\n            this.audio_heap_ptr_outputs = this.audio_heap_ptr_inputs + (this.numIn * this.ptr_size);\n\n            // Setup buffer offset\n            this.audio_heap_inputs = this.audio_heap_ptr_outputs + (this.numOut * this.ptr_size);\n            this.audio_heap_outputs = this.audio_heap_inputs + (this.numIn * NUM_FRAMES * this.sample_size);\n            \n            // Start of DSP memory : DSP is placed first with index 0\n            this.dsp = 0;\n\n            this.pathTable = [];\n         \n            // Send output values to the AudioNode\n            this.update_outputs = function ()\n            {\n                if (this.outputs_items.length > 0 && this.output_handler && this.outputs_timer-- === 0) {\n                    this.outputs_timer = 5;\n                    for (var i = 0; i < this.outputs_items.length; i++) {\n                        this.output_handler(this.outputs_items[i], this.HEAPF32[this.pathTable[this.outputs_items[i]] >> 2]);\n                    }\n                }\n            }\n            \n            this.initAux = function ()\n            {\n                var i;\n                \n                if (this.numIn > 0) {\n                    this.ins = this.audio_heap_ptr_inputs;\n                    for (i = 0; i < this.numIn; i++) {\n                        this.HEAP32[(this.ins >> 2) + i] = this.audio_heap_inputs + ((NUM_FRAMES * this.sample_size) * i);\n                    }\n                    \n                    // Prepare Ins buffer tables\n                    var dspInChans = this.HEAP32.subarray(this.ins >> 2, (this.ins + this.numIn * this.ptr_size) >> 2);\n                    for (i = 0; i < this.numIn; i++) {\n                        this.dspInChannnels[i] = this.HEAPF32.subarray(dspInChans[i] >> 2, (dspInChans[i] + NUM_FRAMES * this.sample_size) >> 2);\n                    }\n                }\n                \n                if (this.numOut > 0) {\n                    this.outs = this.audio_heap_ptr_outputs;\n                    for (i = 0; i < this.numOut; i++) {\n                        this.HEAP32[(this.outs >> 2) + i] = this.audio_heap_outputs + ((NUM_FRAMES * this.sample_size) * i);\n                    }\n                    \n                    // Prepare Out buffer tables\n                    var dspOutChans = this.HEAP32.subarray(this.outs >> 2, (this.outs + this.numOut * this.ptr_size) >> 2);\n                    for (i = 0; i < this.numOut; i++) {\n                        this.dspOutChannnels[i] = this.HEAPF32.subarray(dspOutChans[i] >> 2, (dspOutChans[i] + NUM_FRAMES * this.sample_size) >> 2);\n                    }\n                }\n                \n                // Parse UI\n                tromboneProcessor.parse_ui(this.json_object.ui, this, tromboneProcessor.parse_item2);\n                \n                // Init DSP\n                this.factory.init(this.dsp, sampleRate); // \'sampleRate\' is defined in AudioWorkletGlobalScope  \n            }\n\n            this.setParamValue = function (path, val)\n            {\n                this.HEAPF32[this.pathTable[path] >> 2] = val;\n            }\n\n            this.getParamValue = function (path)\n            {\n                return this.HEAPF32[this.pathTable[path] >> 2];\n            }\n\n            // Init resulting DSP\n            this.initAux();\n        }\n        \n        process(inputs, outputs, parameters) \n        {\n            var input = inputs[0];\n            var output = outputs[0];\n            \n            // Check inputs\n            if (this.numIn > 0 && (!input || !input[0] || input[0].length === 0)) {\n                //console.log("Process input error");\n                return true;\n            }\n            // Check outputs\n            if (this.numOut > 0 && (!output || !output[0] || output[0].length === 0)) {\n                //console.log("Process output error");\n                return true;\n            }\n            \n            // Copy inputs\n            if (input !== undefined) {\n                for (var chan = 0; chan < Math.min(this.numIn, input.length); ++chan) {\n                    var dspInput = this.dspInChannnels[chan];\n                    dspInput.set(input[chan]);\n                }\n            }\n            \n            /*\n            TODO: sample accurate control change is not yet handled\n            When no automation occurs, params[i][1] has a length of 1,\n            otherwise params[i][1] has a length of NUM_FRAMES with possible control change each sample\n            */\n            \n            // Update controls\n            for (const path in parameters) {\n                const paramArray = parameters[path];\n                this.setParamValue(path, paramArray[0]);\n            }\n        \n          \t// Compute\n            try {\n                this.factory.compute(this.dsp, this.NUM_FRAMES, this.ins, this.outs);\n            } catch(e) {\n                console.log("ERROR in compute (" + e + ")");\n            }\n            \n            // Update bargraph\n            this.update_outputs();\n            \n            // Copy outputs\n            if (output !== undefined) {\n                for (var chan = 0; chan < Math.min(this.numOut, output.length); ++chan) {\n                    var dspOutput = this.dspOutChannnels[chan];\n                    output[chan].set(dspOutput);\n                }\n            }\n            \n            return this.running;\n    \t}\n        \n        handleMessage(event)\n        {\n            var msg = event.data;\n            switch (msg.type) {\n                case "destroy": this.running = false; break;\n            }\n        }\n    }\n\n    // Globals\n    // const NUM_FRAMES = 256;\n    try {\n        registerProcessor(\'trombone\', tromboneProcessor);\n    } catch (error) {\n        console.warn(error);\n    }\n';"undefined"==typeof module?(window.trombone=h,window.Fausttrombone=h,window.trombone=h):module.exports={trombone:h};const p=document.getElementById("status");document.getElementById("control");const c=document.getElementById("control_img"),l=window.AudioContext||window.webkitAudioContext||!1;let m;!async function(){try{m=new l({sampleRate:44100});new GainNode(m);m.sampleRate;const t=async function(){await m.resume(),void 0===m.state||m.state};document.addEventListener("pointerdown",t,{once:!0}),document.addEventListener("touchstart",t,{once:!0}),document.addEventListener("keydown",t,{once:!0});const e=new trombone(m),n=await e.load();n.connect(m.destination);const s=n.parameters.get("/trombone/impulse"),a=n.parameters.get("/trombone/lip_x"),o=n.parameters.get("/trombone/tube_extra_length"),i=n.parameters.get("/trombone/flutter"),r=n.parameters.get("/trombone/growl");s.value=1,a.value=100;const h=function(t){s.value=t},u=function(t,e){const{x:n,y:s}=function(t,e){const n=t.getBoundingClientRect();return e.touches&&(e=e.touches[0]),{x:800*(e.clientX-n.left)/n.width,y:400*(n.height-(e.clientY-n.top))/n.height}}(t,e);a.value=n,o.value=s};document.onmouseup=document.ontouchend=()=>{h(1)},document.addEventListener("keydown",(t=>{switch(t.key){case"f":i.value=1;break;case"g":r.value=1;break;case" ":t.preventDefault(),h(0)}})),document.addEventListener("keyup",(t=>{switch(t.key){case"f":i.value=0;break;case"g":r.value=0;break;case" ":t.preventDefault(),h(1)}})),c.onmousedown=c.ontouchstart=t=>{u(c,t),h(0)},c.onmousemove=document.ontouchmove=t=>{u(c,t)},c.addEventListener("contextmenu",(t=>{t.preventDefault()}))}catch(t){throw p.textContent="Sorry, but something went wrong. Please try again with a moderately recent version of Firefox, Edge, or Chrome, or the latest version of Safari.",t}}();
